<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Testing on Emmie' s Workspace</title><link>/tags/testing/</link><description>Recent content in Testing on Emmie' s Workspace</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 17 May 2023 15:43:34 +0800</lastBuildDate><atom:link href="/tags/testing/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 的資料庫(整合)測試 Part 2 - 使用 Testcontainers</title><link>/posts/golang-database-testing-with-testcontainer/</link><pubDate>Wed, 17 May 2023 15:43:34 +0800</pubDate><guid>/posts/golang-database-testing-with-testcontainer/</guid><description>&lt;h2 id="前言">
 &lt;a href="#%e5%89%8d%e8%a8%80" class="anchor">
 &lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
 &lt;path fill-rule="evenodd"
 d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
 &lt;/path>
 &lt;/svg>
 &lt;/a>
 前言
&lt;/h2>
&lt;p>上一篇文章 &lt;a href="/posts/golang-database-testing/">Golang 資料庫(整合)測試&lt;/a> 當中提到了在使用真實資料庫作為測試資料庫時，還可以使用 &lt;a href="https://golang.testcontainers.org/">testcontainers&lt;/a> 讓我們能夠在測試當中直接操作 Docker Container，去建立測試時需要的資料庫環境。這樣一來，也不用像一開始那樣，得另外手動配置一個專門拿來跑測試用的資料庫，將測試整合到 CI/CD 流程上時也比較方便。&lt;/p>
&lt;p>&lt;small> 然後應該是不會有 Part 3 啦。 &lt;/small>&lt;/p></description></item><item><title>Golang 的資料庫(整合)測試</title><link>/posts/golang-database-testing/</link><pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate><guid>/posts/golang-database-testing/</guid><description>&lt;p>&lt;img loading="lazy" 
 src="/images/golang-database-testing-1.png" 
 alt="database-testing-in-golang" 
 
 width=1243 
 height="654" />&lt;/p>
&lt;h2 id="tldr">
 &lt;a href="#tldr" class="anchor">
 &lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
 &lt;path fill-rule="evenodd"
 d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
 &lt;/path>
 &lt;/svg>
 &lt;/a>
 TL;DR
&lt;/h2>
&lt;p>本文記錄了探索在 Golang 當中撰寫資料庫整合測試的過程及方法。包含幾個重點的討論：&lt;/p>
&lt;ol>
&lt;li>進行資料庫測試時，該使用真實的測試資料庫或是測試替身(Test Double)？&lt;/li>
&lt;li>使用測試資料庫的話，該如何重置資料庫狀態，才能避免不同測試方法之間的資料相互影響？&lt;/li>
&lt;li>最後提供讓不同測試方法之間資料不互相影響，並能平行跑測試的實作方法&lt;/li>
&lt;/ol>
&lt;h2 id="前言">
 &lt;a href="#%e5%89%8d%e8%a8%80" class="anchor">
 &lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
 &lt;path fill-rule="evenodd"
 d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
 &lt;/path>
 &lt;/svg>
 &lt;/a>
 前言
&lt;/h2>
&lt;p>有經驗的工程師都知道寫測試對於軟體開發的重要性，而當中最基本的就是單元測試。狹義或者說比較嚴格定義的單元測試，如果以 Clean Architechture 的觀點來看，通常是針對 Domain Layer 以及 Application(Use Case) Layer ，也就是不涉及外部服務或套件/架等等的測試。但對於一些小型專案來說，Domain 邏輯通常不多，大部分都是對資料庫的 CRUD 操作，又或者使用的框架原本就把 ORM 跟 Model 綁死在一起，框架提供的測試集成 API 也是直接預設好對真實資料庫的連接，整個專案可能幾乎沒有幾個狹義的單元測試了。&lt;/p></description></item><item><title>Mock Dynamodb Client(use aws SDK for golang) with testify/mock</title><link>/posts/mock-dynamodb-clientuse-aws-sdk-for-golang-with-testify-mock/</link><pubDate>Thu, 04 Aug 2022 00:00:00 +0000</pubDate><guid>/posts/mock-dynamodb-clientuse-aws-sdk-for-golang-with-testify-mock/</guid><description>&lt;p>測試時若涉及第三方服務，往往會需要運用到 Mock （測試替身）的概念，將外部模組代換成一個假的物件，並模擬其行為與回傳值，讓我們能專注於業務邏輯的單元測試。&lt;/p>
&lt;p>當前的情境為，在 Repository 裡使用 &lt;a href="https://github.com/aws/aws-sdk-go">aws SDK for go&lt;/a> 當中的 dynamodb client 來建立與 dynamodb 的連線以及後續相關對資料庫的操作。但在進行測試時，為了避免每次跑測試都要真的戳資料庫（因在單元測試中，我們只想要確定與 dynamodb client 的互動有&lt;strong>確實呼叫預期的方法、傳入相應的參數&lt;/strong>，而不在乎資料庫到底有沒有寫入資料這種事），會需要將這個 client 替換成 Mock 物件。&lt;/p>
&lt;p>而 &lt;a href="https://github.com/aws/aws-sdk-go">aws SDK for go&lt;/a> 就提供了一個方便開發者進行 mocking 的 interface：&lt;a href="https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/dynamodbiface/">dynamodb interface&lt;/a>&lt;/p>
&lt;p>我們可以直接使用 &lt;a href="https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/dynamodbiface/">dynamodb interface&lt;/a> 作為依賴的類型，也就是說如果要放一個 dynamodb client 在 struct 裡面，原本可能會直接使用 &lt;code>*dynamodb.DynamoDB&lt;/code> 類型：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">dynamodbUserNotificationRepository&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">Client&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">dynamodb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DynamoDB&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 實例化時注入 dynamodb client 依賴
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewDynamondbUserNotificationRepository&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">Client&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">dynamodb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DynamoDB&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nx">domain&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UserNotificationRepository&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">dynamodbUserNotificationRepository&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">Client&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但為了之後方便在測試時能輕鬆注入 Mock 物件，可以替換成 &lt;code>dynamodbiface.DynamoDBAPI&lt;/code> ：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">dynamodbUserNotificationRepository&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">Client&lt;/span> &lt;span class="nx">dynamodbiface&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DynamoDBAPI&lt;/span> &lt;span class="c1">// instead of *dynamodb.DynamoDB
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">NewDynamondbUserNotificationRepository&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">Client&lt;/span> &lt;span class="nx">dynamodbiface&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DynamoDBAPI&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nx">domain&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">UserNotificationRepository&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">dynamodbUserNotificationRepository&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">Client&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>繼續完整這個範例，假設 &lt;code>dynamodbUserNotificationRepository&lt;/code> 有一個 &lt;code>Store&lt;/code> 方法：&lt;/p></description></item></channel></rss>