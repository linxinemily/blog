<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Promise.all() 與 async/await（和 axios） · Emmie's Blog</title><meta name="description" content="Promise.all() 與 async/await（和 axios） - Emmie"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://linxinemily.github.io/atom.xml" title="Emmie's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/linxinemily" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/categories/" target="_self" class="nav-list-link">CATEGORIES</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Promise.all() 與 async/await（和 axios）</h1><a class="article-category-link" href="/categories/Javascript/">Javascript</a><div class="post-info">Jun 30, 2019</div><div class="post-content"><p>本來一直都用迴圈去處理同時發多個 request（很好懂但有點難處理 Error），這次親自來試試 Promise.all() 總算體驗到平行處理非同步的威力（？）於是紀錄一下心得以及和 await + axios 連用時的一些眉角。</p>
<a id="more"></a>
<h2 id="Promise-all-用法"><a href="#Promise-all-用法" class="headerlink" title="Promise.all() 用法"></a>Promise.all() 用法</h2><p>Promise.all () 接受一個陣列作為參數，陣列裡面每個元素都是 Promise 物件(也可以不是，待會會提到），它會同時平行去處理這些 Promise。由於<strong>其本身也是一個 Promise 物件</strong>，所以我們同樣可以用 then 或 await 去接他的 resolve/reject。<br>當 Promise.all () 裡面所有的 Promise 都被 resolve 後才會回傳 resolve，其值會是全部的 Promise 處理完後所回傳的 resolve 值所組成的陣列。但若其中有一個 Promise 被 reject 就會直接拋出該 Promise 所回傳的錯誤。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">const</span> promiseArr = array1.map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(x));</span><br><span class="line"><span class="built_in">console</span>.log(promiseArr) <span class="comment">// [Promise, Promise, Promise, Promise]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 then 接結果</span></span><br><span class="line"><span class="built_in">Promise</span>.all(promiseArr).then(<span class="function"><span class="params">vals</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(vals) <span class="comment">// [1, 4, 9, 16]</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 用 await 接結果</span></span><br><span class="line"><span class="keyword">const</span> vals = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promiseArr)</span><br><span class="line"><span class="built_in">console</span>.log(vals) <span class="comment">// [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提醒： <code>await</code> 後面接的一定會是一個  Promise （或 async function），他會幫我們把 Promise 處理完後直接吐給我們 resovle 或 reject 的值。</p>
</blockquote>
<p>而當陣列裡面有非 Promise 物件的元素存在時，Promise.all() 仍會輸出該元素的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([a, b])</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>


<h2 id="Promise-all-axios"><a href="#Promise-all-axios" class="headerlink" title="Promise.all() + axios"></a>Promise.all() + axios</h2><p>我們可以透過 map() 方法去製造 Promise 陣列（map() 會回傳一組新陣列）在下面的範例中， products 為一組商品物件的陣列，在這裡即利用 map () 遍歷每個物件，將物件資訊帶在 axios 的第二個參數（ request body）， 由於 axios 本身就是一個 promise，所以這樣一來就等同把原始陣列改為 Promise 陣列，就可以直接以丟進 Promise.all() 裡了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(<span class="keyword">this</span>.products.map(<span class="function">(<span class="params">product</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$axios.post(<span class="string">'http://localhost:8000/api/products'</span>, &#123;</span><br><span class="line">          name: product.name,</span><br><span class="line">          price: product.price,</span><br><span class="line">          order_id: myOrder_id</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;))</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br></pre></td></tr></table></figure>

<p>所以我們會得到一個陣列長這樣：</p>
<p><img src="/images/image.png" alt="圖片"></p>
<p>這時發現它長得好像不是我們要的 response data，那是因為 axios 的 response （resolve value）並非直接回 server 給我們的資料 ，而裡面那層 data 才是我們要的資料：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  data: &#123;&#125;, <span class="comment">//這才是 server 回給我們的資料</span></span><br><span class="line">  status: <span class="number">200</span>,</span><br><span class="line">  statusText: <span class="string">'OK'</span>,</span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line">  config: &#123;&#125;,</span><br><span class="line">  request: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2019/06/23/Vue爺孫組件資料傳遞/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="https://linxinemily.github.io">Emmie</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>